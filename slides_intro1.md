## Современные технологии в программировании

## Лекция 7: Модули
---
### Итог по функциям

- Функции являются **объектами**.
- Функция может иметь **параметры**.
- Параметры функции могут иметь **значения по умолчанию**.
- Функции могут иметь **произвольное** количество параметров.
- Функции могут быть **вложенными**.
---
### Итог по функциям

- Могут быть безымянные функции **(лямбда)**.
- **Декораторы** могут быть присоединены к функциям и методам.**
- Функции могут быть частями классов (т.е. **методами**).
- Методы могут принадлежать **объектам класса** или **экземплярам класса.**
- Методы экземпляра класса должны иметь как **минимум один параметр.**
---
### Ключевые моменты из предыдущих лекций

- Классы – это основа объектно-ориентированного подхода.
- Как классы, так и экземпляры классов являются объектами в Python.
- Классы и экземпляры классов имеют атрибуты и методы.
- Методы в Python по умолчанию являются виртуальными.
- Классы и экземпляры классов могут динамически изменять свою структуру и поведение.
---

### Ключевые моменты из предыдущих лекций

- Конструкторы используются для инициализации экземпляров класса.
- Python поддерживает как одиночное, так и множественное наследование.
- Класс может декорировать функцию.
- Класс может декорировать метод какого-либо другого класса.
- Класс может декорировать другой класс.
- В Python программы и/или их части могут быть сконструированы и выполнены динамически "на лету".

---

### Функции, модули и файлы
 
Пример одной (автономной) функции:
```python
def sin(v):
    # логика кода
    return r
```
---

### Функции, модули и файлы

Одна из нескольких функций, составляющих модуль

Пример одной (автономной) функции:
```python
def sin(v):
    # логика кода
```
Пример набора функций (и, возможно, других сущностей):
```python
def sin(v):
    #...

def cos(v):
    #...
#...
```
Логический модуль(выше)

---

### Функции, модули и файлы

Одна из нескольких функций, составляющих модуль

Пример одной (автономной) функции:
```python
def sin(v):
    # логика кода
```
Пример набора функций (и, возможно, других сущностей):
```python
def sin(v):
    #...

def cos(v):
    #...
#...
```
Логический модуль(выше). 
Будучи сохраненным в файл на диске, логический модуль получает имя этого файла (без расширения).

---

### Модули и библиотеки
Например, функция `sin(v)` входит в стандартный модуль `math`, который содержит разные математические функции
---

### Модули и библиотеки
Например, стандартный модуль `math` входит в стандартную библиотеку, которая содержит и другие модули (`os`, `sys`, `random`,`time` и др)

---

### Модули: Определение
(Модуль- это просто) файл с программой на Python. (однако это первое приближение)
Например, файл `FibCollection.py`:
```python
def fib1(n):
    ```Prints Fibbonacci numbers untill n```
    a,b = 0 , 1
    while b < n:
        print(b)
        a,b = b, a+b
def fib2(n):
    ```Returns the list with n first Fibonacci numbers```
    result = []
    a,b = 0 , 1
    while b < n:
        result.append(b)
        a,b = b, a+b
    return result
```

---

### Модули: Определение
- Каждый модуль вводит свою собственную  область видимости; это означает, что объекты, объявленные в модуле, являются  локальными для этого модуля.
- Модуль может содержать любые объекты Python: не только функции, но и переменные, классы и т.д
- Члены модуля называются атрибутами, так же как и члены класса

---

### Модули: Использование
Реальная ценность модуля заключается в том, что он используется какой-либо другой программой на Python.
```python
# Это имя файла (без расширения имени), содержащего импортируемый модуль
import FibCollection
# Имена объектов модуля доступны только с помощью точечной нотации
FibCollection.fib1(1000)
```

---

### Модули: Использование
Реальная ценность модуля заключается в том, что он используется какой-либо другой программой на Python.
```python
# Это имя файла (без расширения имени), содержащего импортируемый модуль
import FibCollection
# Имена объектов модуля доступны только с помощью точечной нотации
FibCollection.fib1(1000)
# Error: unknown name 'fib1'
fib1(100)
```
Когда модуль импортируется, его имя – но не имена его сущностей – становится известным в программе, использующей модуль. Следовательно, единственный способ получить доступ к объектам, объявленным в импортированном модуле, - это  использовать точечную нотацию

---

### Модули: Использование
Более конкретная версия конструкции импорта.
В чем разница между предыдущей конструкцией и этой?
```python
from FibCollection import fib1, fib2

fib1(100) # valid call

FibCollection.fib1(1000)
```

---

### Модули: Использование
Более конкретная версия конструкции импорта.
В чем разница между предыдущей конструкцией и этой?
Ответ: Здесь импортируются имена объектов модуля, но не сам модуль!
```python
from FibCollection import fib1, fib2

fib1(100) # valid call

FibCollection.fib1(1000)
```
Когда имена импортируются, они добавляются в текущую область и доступны через их простые имена

---

### Модули: Использование
Более конкретная версия конструкции импорта.
В чем разница между предыдущей конструкцией и этой?
Ответ: Здесь импортируются имена объектов модуля, но не сам модуль!
```python
from FibCollection import fib1, fib2

fib1(100) # valid call

FibCollection.fib1(1000) #illegal
```
Когда имена импортируются, они добавляются в текущую область и доступны через их простые имена
Модуль `FibCollection` не импортирован, поэтому он неизвестен в программе

---

### Модули: Использование
Еще одна конкретная версия конструкции импорта.
```python
from FibCollection import *
```

---

### Модули: Использование
Еще одна конкретная версия конструкции импорта.
```python
from FibCollection import *
```
`*` означает, что все объекты из модуля импортируются в программу...

---
### Модули: Использование
Еще одна конкретная версия конструкции импорта.
```python
from FibCollection import *
```
`*` означает, что все объекты из модуля импортируются в программу...
..за двумя исключениями:
- Имя самого модуля не импортируется
- Имена, объявленные внутри модуля и начинающиеся с символа подчеркивания `_`, не импортируются
**Вопрос: Как и где Python выполняет поиск файла модуля?- ознакомьтесь с документацией**
---

### Модули: Использование
Еще одна специфическая версия конструкции импорта.
Вместо использования конструкций с длинными именами...
```python
import FibCollection
FibCollection.fib1(1000)
#...
```
...Мы можем ввести более короткий алиэс:
```python
import FibCollection as FC
FC.fib1(1000)
#...
```
То же самое касается импортированных объектов:
```python
from math import sin as s
x=s(1)
#...
```

---

### Замечание: `__name__`
`__name__` является универсальным атрибутом, применимым к некоторым объектам Python
```python
def myFunc(n):
    return(n*n)

myFunc.__name__ #'myFunc'
f = myFunc
f.__name__ #'myFunc'
```

```python
import FibCollection as FC
FibCollection.__name__ #'FibCollection'
FC.__name__ #'FibCollection'
```

```python
from math import sin as sinnn
sin.__name__ #'sin'
sinnn.__name__ #'sin'
```

---

### Модули - это объекты!
Файл `myLib.py`
```python
def quad(a):
    return a*a
def qube(a):
    return a*a*a
```
Доступ к элементам модуля осуществляется через модуль "имя"
```python
import myLib

quad(3)
myLib1.cube(5)
```
Пока все хорошо...

---

### Модули - это объекты!
Файл `myLib.py`
```python
def quad(a):
    return a*a
def qube(a):
    return a*a*a
```
Доступ к элементам модуля осуществляется через модуль "имя"
```python
import myLib

quad(3)
myLib1.cube(5)
```
Пока все хорошо...

```python
import myLib

x = myLib
```
**Wow!!!**
Теперь `x` ссылается на объект модуля!

---

### Модули - это объекты!
Файл `myLib.py`
```python
def quad(a):
    return a*a
def qube(a):
    return a*a*a
```
Доступ к элементам модуля осуществляется через модуль "имя"
```python
import myLib

quad(3)
myLib1.cube(5)
```
Пока все хорошо...

---

### Модули - это объекты!
```python
import myLib

x = myLib

# Доступ к элементам модуля по ссылке
r1 = x.quad(3)
r2 = x.cube(5)
```
**Wow!!!**
Теперь x ссылается на объект модуля!

---

### Модули - это объекты!
Как убедиться, что `x` действительно ссылается на модуль `myLib`: `help` стандартная функция

```
>>> help(x)
Help on module myLib:
NAME
myLib  
FUNCTIONS
quad(a)
cube(a)
FILE
c:\users\alex\appdata\local\programs\python\python37\myLib.py
>>>
```

---

### Модули - это объекты!
Что еще мы можем сделать с модулями (ссылками на них)?
- Передавать их функциям в качестве аргументов!!
```python
import myLib
import otherLib
x = myLib
def myQuad(module, a):
    return module.quad(a)
myQuad(x,7)
y = otherLib
myQuad(y,7)
```

Предположим `otherLib` содержит `quad` также...

---

### Модули - это объекты!
Что еще мы можем сделать с модулями (ссылками на них)?
- Возвращать как результат функции!

```python
import math # стандартный модуль
import my_math # какой то другой модуль

def choose_library(a):
    return math if a<1000 else my_math

value1 = choose_library.sin(7)
value2 = choose_library.sin(7777)
```

---
### Модули - это объекты!
Проблемы с динамической природой Python и атрибутами модуля.
File `myLib.py`:
```python
def quad(a):
    return a*a
def cube(a):
    return a*a*a
```
```python
import myLib
def callModuleAttr(m,a,v):  
    return m.a(v)
r1 = callModuleAtts(myLib,cube,3) # NameError: name `cube` is not defined
r2 = callModuleAtts(myLib,myLib.cube,3) # AttributeError: module `myLib` has no attribute `a` 
```

---

### Модули: Что пропущено
- Модули и пути к файлам
- Предварительно скомпилированные  модули; файлы `.py` и `.pyc`
- Стандартные модули: `sys`, `math` и т.д.
- Подмодули и пакеты
Все эти темы (а также некоторые другие) предназначены для вашего домашнего изучения и экспериментов




